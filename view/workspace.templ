package view

import (
	"fmt"
	"github.com/bacchus-snu/sgs/model"
	"slices"
	"strings"
)

var (
	classDisabled = []string{"border-gray-300", "text-gray-600"}
	classLabel    = []string{"py-2", "font-bold", "text-right"}

	classButtonBase    = []string{"rounded", "px-4", "py-2", "font-bold", "outline", "outline-1"}
	classButtonPrimary = append(classButtonBase,
		[]string{"bg-blue-500", "text-white", "outline-blue-500", "hover:bg-blue-700", "focus:bg-blue-700"}...)
	classButtonSecondary = append(classButtonBase,
		[]string{"text-blue-600", "outline-blue-600", "hover:bg-blue-200", "focus:bg-blue-200"}...)
	classButtonDestructive = append(classButtonBase,
		[]string{"text-red-600", "outline-red-600", "hover:bg-red-200", "focus:bg-red-200"}...)
	classButtonGreen = append(classButtonBase,
		[]string{"bg-green-500", "text-white", "outline-green-500", "hover:bg-green-700", "focus:bg-green-700"}...)
)

templ PageWorkspaceList(wss []*model.Workspace, invitations []*model.Workspace) {
	@page("Workspaces") {
		if len(invitations) > 0 {
			<section class="mb-8">
				<h2 class="mb-4 text-xl font-bold">My Invitations</h2>
				<ul class="mx-auto max-w-screen-md space-y-4">
					for _, ws := range invitations {
						<li class="rounded p-4 border-2 border-blue-300 bg-blue-50">
							<div class="flex items-center justify-between">
								<div class="flex items-baseline">
									<h1 class="text-lg font-mono font-bold">{ ws.ID.Hash() }</h1>
									<h2 class="ml-2 text-gray-500">ID: { fmt.Sprint(ws.ID) }</h2>
									@wsStatusButton(ws)
								</div>
								<div class="flex gap-2">
									<form method="post" action={ templ.URL(fmt.Sprintf("/ws/%s/accept", ws.ID.Hash())) }>
										<input type="hidden" name="_csrf" value={ ctxCSRF(ctx) }/>
										<button class={ classButtonPrimary } type="submit">Accept</button>
									</form>
									<form method="post" action={ templ.URL(fmt.Sprintf("/ws/%s/decline", ws.ID.Hash())) }>
										<input type="hidden" name="_csrf" value={ ctxCSRF(ctx) }/>
										<button class={ classButtonDestructive } type="submit">Decline</button>
									</form>
								</div>
							</div>
							<div class="mt-2">
								<span class="text-gray-500">Users: { strings.Join(model.Usernames(ws.Users), ", ") }</span>
								<span class="text-gray-500 ml-4">GPU quota: { fmt.Sprint(ws.Quotas[model.ResGPURequest]) }</span>
							</div>
						</li>
					}
				</ul>
			</section>
		}
		<h1 class="mb-4 text-xl font-bold">My workspaces</h1>
		<ul class="mx-auto max-w-screen-md space-y-4">
			for _, ws := range wss {
				<a href={ templ.URL(fmt.Sprintf("/ws/%s", ws.ID.Hash())) }>
					<li class="rounded p-2 hover:bg-gray-200">
						<div class='flex items-baseline'>
							<h1 class="text-lg font-mono font-bold">{ ws.ID.Hash() }</h1>
							<h2 class="ml-2 text-gray-500">ID: { fmt.Sprint(ws.ID) }</h2>
							@wsStatusButton(ws)
						</div>
						<div>
							<span class="text-gray-500">Users: { strings.Join(model.Usernames(ws.Users), ", ") }</span>
							<span class="text-gray-500">GPU quota: { fmt.Sprint(ws.Quotas[model.ResGPURequest]) }</span>
						</div>
					</li>
				</a>
			}
		</ul>
	}
}

// Apply changes to workspace, for rendering requested changes.
func wsUpdated(ws *model.Workspace) *model.Workspace {
	if ws.Request == nil {
		return ws
	}

	newWS := *ws
	newWS.Enabled = ws.Request.Enabled
	newWS.Nodegroup = ws.Request.Nodegroup
	newWS.Userdata = ws.Request.Userdata
	newWS.Quotas = ws.Request.Quotas

	// Convert []string to []WorkspaceUser, preserving email from existing users
	existingUsers := make(map[string]string) // username -> email
	for _, u := range ws.Users {
		existingUsers[u.Username] = u.Email
	}
	newWS.Users = make([]model.WorkspaceUser, len(ws.Request.Users))
	for i, username := range ws.Request.Users {
		newWS.Users[i] = model.WorkspaceUser{
			Username: username,
			Email:    existingUsers[username], // will be empty for new users
		}
	}
	return &newWS
}

templ PageWorkspaceDetails(ws *model.Workspace) {
	@page("Workspace Details") {
		@workspaceDetails(ws, wsUpdated(ws))
	}
}

// Render the status badge
templ wsStatusButton(ws *model.Workspace) {
	switch true {
		case !ws.Created && ws.Request != nil:
			// pending approval (initial state)
			<span class="ml-4 rounded-full border border-amber-700 bg-amber-200 text-amber-700 px-2">Pending</span>
		case !ws.Created && ws.Request == nil:
			// request has been rejected
			<span class="ml-4 rounded-full border border-amber-700 bg-red-200 text-red-700 px-2">Rejected</span>
		case ws.Enabled && ws.Request == nil:
			// enabled
			<span class="ml-4 rounded-full border border-green-700 bg-green-200 text-green-700 px-2">Enabled</span>
		case !ws.Enabled && ws.Request == nil:
			// disabled
			<span class="ml-4 rounded-full border border-amber-700 bg-red-200 text-red-700 px-2">Disabled</span>
		case ws.Enabled && ws.Request != nil:
			// enabled, changes requested
			<span class="ml-4 rounded-full border border-green-700 bg-green-200 text-green-700 px-2">Enabled, pending request</span>
		case !ws.Enabled && ws.Request != nil:
			// disabled, changes requested
			<span class="ml-4 rounded-full border border-amber-700 bg-red-200 text-red-700 px-2">Disabled, pending request</span>
	}
}

templ workspaceDetails(ws, newWS *model.Workspace) {
	<div class='flex items-baseline'>
		<h1 class="text-lg font-bold font-mono">{ ws.ID.Hash() }</h1>
		<h2 class="ml-2 text-gray-500">ID: { fmt.Sprint(ws.ID) }</h2>
		@wsStatusButton(ws)
	</div>
	if ws.Request != nil {
		<div><span class="text-gray-500">Changes requested by</span> { ws.Request.ByUser }</div>
	}
	<form class="mt-4" method="post" onsubmit={ wsValidateForm() }>
		<div class="grid grid-cols-3 gap-4">
			<span class="font-bold text-center col-start-2">Current</span>
			<span class="font-bold text-center">Changes</span>
			<label class={ classLabel }>Enabled</label>
			<input class={ "justify-self-center", "self-center", classDisabled } type="checkbox" checked?={ ws.Enabled } disabled/>
			<input class="justify-self-center self-center" type="checkbox" id="enabled" name="enabled" checked?={ newWS.Enabled }/>
			<label class={ classLabel }>Nodegroup</label>
			<select class={ classDisabled } disabled>
				<option>{ string(ws.Nodegroup) }</option>
			</select>
			<select id="nodegroup" name="nodegroup" required>
				<option value="">Select a nodegroup</option>
				for _, ng := range model.Nodegroups {
					if user := ctxUser(ctx); user.IsAdmin() || slices.Contains(user.Groups, string(ng)) {
						<option value={ string(ng) } selected?={ ng == newWS.Nodegroup }>{ string(ng) }</option>
					}
				}
			</select>
			<label class={ classLabel }>Reason</label>
			<textarea class={ "resize-none", classDisabled } rows="10" disabled>{ ws.Userdata }</textarea>
			<textarea class="resize-none" id="userdata" name="userdata" rows="10" required>{ newWS.Userdata }</textarea>
			// GPUs with oninput handler
			<label class={ classLabel }>
				GPUs
			</label>
			<input class={ "h-fit", classDisabled } value={ fmt.Sprint(ws.Quotas[model.ResGPURequest]) } disabled/>
			<input class="h-fit" id="quota-gpu" name="quota-gpu" type="number" min="0" value={ fmt.Sprint(newWS.Quotas[model.ResGPURequest]) } required oninput={ wsUpdateDefaults() }/>
			<div class="col-start-1"></div>
			<p class="col-start-3 text-sm text-gray-500">
				Number of GPU compute units that can run simultaneously.
			</p>
			// GPU Memory with oninput handler
			<label class={ classLabel }>
				GPU Memory (per GPU)
				<span class="text-sm font-normal text-gray-500">GiB</span>
			</label>
			<input class={ "h-fit", classDisabled } value={ fmt.Sprint(ws.Quotas[model.ResGPUMemoryRequest]) } disabled/>
			<input class="h-fit" id="quota-gpu-memory" name="quota-gpu-memory" type="number" min="0" step="any" value={ fmt.Sprint(newWS.Quotas[model.ResGPUMemoryRequest]) } required oninput={ wsUpdateDefaults() }/>
			@wsQuotaInput("Storage", "quota-storage", "GiB", model.ResStorageRequest, ws, newWS)
			// Explanation text
			<div class="col-start-1"></div>
			<p class="col-start-3 text-sm text-gray-500">
				By default, <span class="font-bold">8 CPUs per GPU</span> and
				<span class="font-bold">1.5× total GPU memory as host memory</span> are allocated as limits.
				You may increase these values if needed, but please explain why in the Reason field above.
			</p>
			// CPU Limit with guarantee checkbox in both columns
			<label class={ classLabel }>
				CPUs
			</label>
			<div class="flex items-center gap-2">
				<input class={ "h-fit", "flex-1", classDisabled } value={ fmt.Sprint(ws.Quotas[model.ResCPULimit]) } disabled/>
				<input type="checkbox" checked?={ ws.Quotas[model.ResCPURequest] > 0 } disabled/>
				<span class="text-sm text-gray-500">Guarantee</span>
			</div>
			<div class="flex items-center gap-2">
				<input class="h-fit flex-1" id="quota-cpu-limits" name="quota-cpu-limits" type="number" min="0" value={ fmt.Sprint(newWS.Quotas[model.ResCPULimit]) } required oninput={ wsValidateLimits() }/>
				<input type="checkbox" id="guarantee-cpu" name="guarantee-cpu" checked?={ newWS.Quotas[model.ResCPURequest] > 0 } onchange={ wsToggleGuaranteeCPU() }/>
				<label for="guarantee-cpu" class="text-sm whitespace-nowrap">Guarantee</label>
			</div>
			<p id="cpu-error" class="hidden col-start-3 text-sm text-red-600 font-bold"></p>
			if newWS.Quotas[model.ResCPURequest] > 0 {
				<div id="cpu-warning-spacer" class="col-start-1"></div>
				<p id="cpu-warning" class="col-start-3 text-sm text-amber-600">
					⚠️ Guaranteed resources are reserved exclusively for your workspace.
					Only enable this for workloads requiring resource isolation (e.g., performance benchmarking).
					This may prevent other users from creating sessions due to resource scarcity.
				</p>
			} else {
				<div id="cpu-warning-spacer" class="hidden col-start-1"></div>
				<p id="cpu-warning" class="hidden col-start-3 text-sm text-amber-600">
					⚠️ Guaranteed resources are reserved exclusively for your workspace.
					Only enable this for workloads requiring resource isolation (e.g., performance benchmarking).
					This may prevent other users from creating sessions due to resource scarcity.
				</p>
			}
			// Memory Limit with guarantee checkbox in both columns
			<label class={ classLabel }>
				Host Memory
				<span class="text-sm font-normal text-gray-500">GiB</span>
			</label>
			<div class="flex items-center gap-2">
				<input class={ "h-fit", "flex-1", classDisabled } value={ fmt.Sprint(ws.Quotas[model.ResMemoryLimit]) } disabled/>
				<input type="checkbox" checked?={ ws.Quotas[model.ResMemoryRequest] > 0 } disabled/>
				<span class="text-sm text-gray-500">Guarantee</span>
			</div>
			<div class="flex items-center gap-2">
				<input class="h-fit flex-1" id="quota-memory-limits" name="quota-memory-limits" type="number" min="0" step="any" value={ fmt.Sprint(newWS.Quotas[model.ResMemoryLimit]) } required oninput={ wsValidateLimits() }/>
				<input type="checkbox" id="guarantee-memory" name="guarantee-memory" checked?={ newWS.Quotas[model.ResMemoryRequest] > 0 } onchange={ wsToggleGuaranteeMemory() }/>
				<label for="guarantee-memory" class="text-sm whitespace-nowrap">Guarantee</label>
			</div>
			<p id="memory-error" class="hidden col-start-3 text-sm text-red-600 font-bold"></p>
			if newWS.Quotas[model.ResMemoryRequest] > 0 {
				<div id="memory-warning-spacer" class="col-start-1"></div>
				<p id="memory-warning" class="col-start-3 text-sm text-amber-600">
					⚠️ Guaranteed resources are reserved exclusively for your workspace.
					Only enable this for workloads requiring resource isolation (e.g., performance benchmarking).
					This may prevent other users from creating sessions due to resource scarcity.
				</p>
			} else {
				<div id="memory-warning-spacer" class="hidden col-start-1"></div>
				<p id="memory-warning" class="hidden col-start-3 text-sm text-amber-600">
					⚠️ Guaranteed resources are reserved exclusively for your workspace.
					Only enable this for workloads requiring resource isolation (e.g., performance benchmarking).
					This may prevent other users from creating sessions due to resource scarcity.
				</p>
			}
			<label class={ classLabel }>Users</label>
			<div class="space-y-1">
				for _, user := range ws.Users {
					<div class="flex items-center gap-2 p-1">
						if user.IsAccepted() {
							<div class="h-2.5 w-2.5 rounded-full bg-green-500" title="Accepted"></div>
						} else {
							<div class="h-2.5 w-2.5 rounded-full bg-red-500" title="Pending invitation"></div>
						}
						<span class={ classDisabled }>{ user.Username }</span>
						if user.Email != "" {
							<span class="text-gray-500 text-sm">({ user.Email })</span>
						}
					</div>
				}
			</div>
			<div class="flex flex-col space-y-1">
				for i, user := range newWS.Users {
					<div class="flex items-center gap-x-2">
						<input class="h-fit flex-1" id={ fmt.Sprintf("user-%d", i) } name={ fmt.Sprintf("user-%d", i) } value={ user.Username } required/>
						<button class={ classButtonDestructive, "w-20" } type="button" onclick={ wsRemoveUser() }>Delete</button>
					</div>
				}
				<div id="add-user-row" class="flex items-center gap-x-2">
					<input class="h-fit flex-1" id={ fmt.Sprintf("user-%d", len(newWS.Users)) } name={ fmt.Sprintf("user-%d", len(newWS.Users)) } placeholder="Add new user..."/>
					<button class={ classButtonSecondary, "w-20" } type="button" onclick={ wsAddNewUser() }>Add</button>
				</div>
			</div>
		</div>
		<input type="hidden" id="quota-cpu-requests" name="quota-cpu-requests" value={ fmt.Sprint(newWS.Quotas[model.ResCPURequest]) }/>
		<input type="hidden" id="quota-memory-requests" name="quota-memory-requests" value={ fmt.Sprint(newWS.Quotas[model.ResMemoryRequest]) }/>
		<input type="hidden" name="_csrf" value={ ctxCSRF(ctx) }/>
		<div class="m-4 flex flex-wrap justify-center gap-4">
			if slices.Contains(model.Usernames(ws.Users), ctxUser(ctx).Username) {
				// The user may be an admin & not in the user list in which case they're not allowed to request changes.
				// They can outright update or delete the workspace instead.
				<button class={ classButtonPrimary } name="action" value="request">
					Request changes
				</button>
			}
			if ctxUser(ctx).IsAdmin() {
				<button class={ classButtonSecondary } name="action" value="update">
					Update
				</button>
				<button class={ classButtonDestructive } name="action" value="delete">
					Delete
				</button>
			}
		</div>
	</form>
}

templ wsQuotaInput(label, name, units string, res model.Resource, ws, newWS *model.Workspace) {
	<label class={ classLabel }>
		{ label }
		if units != "" {
			<span class="text-sm font-normal text-gray-500">{ units }</span>
		}
	</label>
	<input class={ "h-fit", classDisabled } value={ fmt.Sprint(ws.Quotas[res]) } disabled/>
	<input class="h-fit" id={ name } name={ name } type="number" min="0" step="any" value={ fmt.Sprint(newWS.Quotas[res]) } required/>
}

script wsRemoveUser() {
	const container = event.target.parentNode.parentNode
	// Keep at least the add-user-row + 1 existing user
	if (container.childElementCount > 2) {
		event.target.parentNode.remove()
	}
}

script wsAddNewUser() {
	const addRow = document.getElementById('add-user-row')
	const input = addRow.children[0]  // Input is first child (no indicator)
	const username = input.value.trim()

	if (!username) {
		input.focus()
		return
	}

	// Create new user row with Delete button (no indicator)
	const newRow = document.createElement('div')
	newRow.className = 'flex items-center gap-x-2'

	// Input with current value
	const newInput = document.createElement('input')
	newInput.className = 'h-fit flex-1'
	const nextId = Number.parseInt(input.id.split('-')[1])
	newInput.id = `user-${nextId}`
	newInput.name = `user-${nextId}`
	newInput.value = username
	newInput.required = true
	newRow.appendChild(newInput)

	// Delete button with fixed width
	const deleteBtn = document.createElement('button')
	deleteBtn.className = 'rounded px-4 py-2 font-bold outline outline-1 text-red-600 outline-red-600 hover:bg-red-200 focus:bg-red-200 w-20'
	deleteBtn.type = 'button'
	deleteBtn.textContent = 'Delete'
	deleteBtn.onclick = function() {
		const container = this.parentNode.parentNode
		if (container.childElementCount > 2) {
			this.parentNode.remove()
		}
	}
	newRow.appendChild(deleteBtn)

	// Insert before add-user-row
	addRow.parentNode.insertBefore(newRow, addRow)

	// Update add-user-row input id and clear it
	input.id = `user-${nextId + 1}`
	input.name = `user-${nextId + 1}`
	input.value = ''
}

script wsUpdateDefaults() {
	const gpuCount = parseInt(document.getElementById('quota-gpu').value) || 0;
	const gpuMemGiB = parseFloat(document.getElementById('quota-gpu-memory').value) || 0;

	const minCpu = gpuCount * 8;
	const minMemGiB = gpuCount * gpuMemGiB * 1.5;

	const cpuInput = document.getElementById('quota-cpu-limits');
	const memInput = document.getElementById('quota-memory-limits');

	// Update minimum attributes (use raw floating point for validation)
	cpuInput.min = minCpu;
	memInput.min = minMemGiB;

	// Always update to calculated defaults when GPU values change
	cpuInput.value = minCpu;
	memInput.value = minMemGiB;

	// Clear any validation errors since we just set valid values
	const cpuError = document.getElementById('cpu-error');
	const memError = document.getElementById('memory-error');
	cpuInput.classList.remove('border-red-500', 'border-2');
	cpuError.classList.add('hidden');
	memInput.classList.remove('border-red-500', 'border-2');
	memError.classList.add('hidden');
}

script wsValidateLimits() {
	const gpuCount = parseInt(document.getElementById('quota-gpu').value) || 0;
	const gpuMemGiB = parseFloat(document.getElementById('quota-gpu-memory').value) || 0;

	const minCpu = gpuCount * 8;
	const minMemGiB = gpuCount * gpuMemGiB * 1.5;

	const cpuInput = document.getElementById('quota-cpu-limits');
	const memInput = document.getElementById('quota-memory-limits');
	const cpuError = document.getElementById('cpu-error');
	const memError = document.getElementById('memory-error');

	const cpuValue = parseInt(cpuInput.value) || 0;
	const memValue = parseFloat(memInput.value) || 0;

	// CPU validation
	if (cpuValue < minCpu) {
		cpuInput.classList.add('border-red-500', 'border-2');
		cpuError.textContent = `CPUs must be at least ${minCpu} (8 × ${gpuCount} GPUs)`;
		cpuError.classList.remove('hidden');
	} else {
		cpuInput.classList.remove('border-red-500', 'border-2');
		cpuError.classList.add('hidden');
	}

	// Memory validation
	if (memValue < minMemGiB) {
		memInput.classList.add('border-red-500', 'border-2');
		memError.textContent = `Host Memory must be at least ${minMemGiB} GiB (1.5 × ${gpuCount} GPUs × ${gpuMemGiB} GiB)`;
		memError.classList.remove('hidden');
	} else {
		memInput.classList.remove('border-red-500', 'border-2');
		memError.classList.add('hidden');
	}
}

script wsToggleGuaranteeCPU() {
	const checkbox = document.getElementById('guarantee-cpu');
	const warningSpacer = document.getElementById('cpu-warning-spacer');
	const warning = document.getElementById('cpu-warning');
	const limitInput = document.getElementById('quota-cpu-limits');
	const requestInput = document.getElementById('quota-cpu-requests');

	if (checkbox.checked) {
		warningSpacer.classList.remove('hidden');
		warning.classList.remove('hidden');
		requestInput.value = limitInput.value;
	} else {
		warningSpacer.classList.add('hidden');
		warning.classList.add('hidden');
		requestInput.value = '0';
	}
}

script wsToggleGuaranteeMemory() {
	const checkbox = document.getElementById('guarantee-memory');
	const warningSpacer = document.getElementById('memory-warning-spacer');
	const warning = document.getElementById('memory-warning');
	const limitInput = document.getElementById('quota-memory-limits');
	const requestInput = document.getElementById('quota-memory-requests');

	if (checkbox.checked) {
		warningSpacer.classList.remove('hidden');
		warning.classList.remove('hidden');
		requestInput.value = limitInput.value;
	} else {
		warningSpacer.classList.add('hidden');
		warning.classList.add('hidden');
		requestInput.value = '0';
	}
}

script wsValidateForm() {
	const gpuCount = parseInt(document.getElementById('quota-gpu').value) || 0;
	const gpuMemGiB = parseFloat(document.getElementById('quota-gpu-memory').value) || 0;

	const minCpu = gpuCount * 8;
	const minMemGiB = gpuCount * gpuMemGiB * 1.5;

	const cpuValue = parseInt(document.getElementById('quota-cpu-limits').value) || 0;
	const memValue = parseFloat(document.getElementById('quota-memory-limits').value) || 0;

	// Round floating point values to integers before submission (backend expects uint64)
	document.getElementById('quota-gpu-memory').value = Math.ceil(gpuMemGiB);
	document.getElementById('quota-storage').value = Math.ceil(parseFloat(document.getElementById('quota-storage').value) || 0);
	document.getElementById('quota-memory-limits').value = Math.ceil(memValue);

	// Update request values based on guarantee checkboxes before submit
	const cpuCheckbox = document.getElementById('guarantee-cpu');
	const memCheckbox = document.getElementById('guarantee-memory');
	document.getElementById('quota-cpu-requests').value = cpuCheckbox.checked ? cpuValue : 0;
	document.getElementById('quota-memory-requests').value = memCheckbox.checked ? Math.ceil(memValue) : 0;

	if (cpuValue < minCpu || memValue < minMemGiB) {
		event.preventDefault();
		wsValidateLimits();
		return false;
	}
	return true;
}
